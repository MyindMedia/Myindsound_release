{
    "history": [
        {
            "breakpoints": [],
            "visible": false,
            "aspectRatio": 1,
            "userDownsample": 1,
            "layerType": "effect",
            "type": "gradient",
            "usesPingPong": false,
            "speed": 0.6,
            "trackMouse": 0,
            "trackAxes": "xy",
            "mouseMomentum": 0,
            "texture": false,
            "animating": false,
            "isMask": 0,
            "compiledFragmentShaders": [
                "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform float uTime;\nuniform vec2 uMousePos;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0, 0);\ncase 1: return vec3(0.396078431372549, 0.4392156862745098, 0.9882352941176471);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0, 0, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}float getStop(int index) {\nswitch(index) {\ncase 0: return 0.0000;\ncase 1: return 1.0000;\ncase 2: return 0.0000;\ncase 3: return 0.0000;\ncase 4: return 0.0000;\ncase 5: return 0.0000;\ncase 6: return 0.0000;\ncase 7: return 0.0000;\ncase 8: return 0.0000;\ncase 9: return 0.0000;\ncase 10: return 0.0000;\ncase 11: return 0.0000;\ncase 12: return 0.0000;\ncase 13: return 0.0000;\ncase 14: return 0.0000;\ncase 15: return 0.0000;\ndefault: return 0.0;\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}vec3 linear_from_srgb(vec3 rgb) {\nreturn pow(max(rgb, vec3(0.0)), vec3(2.2));\n}vec3 srgb_from_linear(vec3 lin) {\nreturn pow(max(lin, vec3(0.0)), vec3(1.0/2.2));\n}vec3 safeCbrt(vec3 v) {\nreturn sign(v) * pow(abs(v), vec3(1.0/3.0));\n}vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) {\nconst mat3 kCONEtoLMS = mat3(\n0.4121656120, 0.2118591070, 0.0883097947,\n0.5362752080, 0.6807189584, 0.2818474174,\n0.0514575653, 0.1074065790, 0.6302613616);\nconst mat3 kLMStoCONE = mat3(\n4.0767245293, -1.2681437731, -0.0041119885,\n-3.3072168827, 2.6093323231, -0.7034763098,\n0.2307590544, -0.3411344290, 1.7068625689);\nvec3 lms1 = safeCbrt( kCONEtoLMS*lin1 );\nvec3 lms2 = safeCbrt( kCONEtoLMS*lin2 );\nvec3 lms = mix( lms1, lms2, a );\nlms *= 1.0 + 0.025 * a * (1.0-a);\nreturn kLMStoCONE * (lms * lms * lms);\n}vec3 getGradientColor(float position) {\nposition = clamp(position, 0.0, 1.0);\nif (2 <= 1) return getColor(0);for (int i = 0; i < 15; i++) {\nif (i >= 2 - 1) break;\nfloat stopA = getStop(i);\nfloat stopB = getStop(i + 1);\nif (position <= stopB || i == 2 - 2) {\nfloat denom = max(stopB - stopA, 0.00001);\nfloat t = clamp((position - stopA) / denom, 0.0, 1.0);\nvec3 linA = linear_from_srgb(getColor(i));\nvec3 linB = linear_from_srgb(getColor(i + 1));\nvec3 mixed = oklab_mix(linA, linB, t);\nreturn srgb_from_linear(mixed);\n}\n}\nreturn getColor(min(2 - 1, 15));\n}out vec4 fragColor;vec3 applyColorToPosition(float position) {\nvec3 color = vec3(0);\nposition -= (uTime * 0.01 + 1.0000);\nfloat cycle = floor(position);\nbool reverse = 1.0000 > 0.5 && int(cycle) % 2 == 0;\nfloat animatedPos = reverse ? 1.0 - fract(position) : fract(position);color = getGradientColor(animatedPos);\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor += dither;\nreturn color;\n}vec3 linearGrad(vec2 uv) {\nfloat position = (uv.x+0.5);\nreturn applyColorToPosition(position);\n}vec3 getGradient(vec2 uv) {\nreturn linearGrad(uv);\n}vec3 getColor(vec2 uv) {return getGradient(uv);return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= max(0.6100*2., 1e-5);\nuv = rotate(uv, (0.4725 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 1.0000);\nfragColor = color;\n}"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"
            ],
            "data": {
                "depth": false,
                "uniforms": {},
                "isBackground": true
            },
            "id": "gradient"
        },
        {
            "breakpoints": [],
            "visible": false,
            "aspectRatio": 1,
            "userDownsample": 1,
            "states": {
                "appear": [
                    {
                        "local": {
                            "pendingChanges": {},
                            "changeDebouncer": null,
                            "dragSession": null
                        },
                        "type": "appear",
                        "id": "ef44b178-267e-480e-ab88-c6c5703037f5",
                        "prop": "thickness",
                        "transition": {
                            "duration": 1000,
                            "ease": "easeInOutQuart",
                            "delay": 0
                        },
                        "complete": false,
                        "progress": 0,
                        "value": 0,
                        "endValue": 0.16,
                        "initialized": false,
                        "breakpoints": [],
                        "loop": "none",
                        "loopDelay": 0,
                        "uniformData": {
                            "type": "1f",
                            "name": "uThickness"
                        }
                    }
                ],
                "scroll": [],
                "hover": [],
                "mousemove": []
            },
            "layerType": "effect",
            "type": "beam",
            "usesPingPong": false,
            "thickness": 0.16,
            "speed": 0.6,
            "trackMouse": 0,
            "trackAxes": "xy",
            "mouseMomentum": 0,
            "texture": false,
            "animating": true,
            "isMask": 0,
            "compiledFragmentShaders": [
                "#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uThickness;\nuniform float uTime;uniform vec2 uMousePos;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float TAU = 6.28318530718;vec3 Tonemap_tanh(vec3 x) {\nx = clamp(x, -40.0, 40.0);\nreturn (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}out vec4 fragColor;const float PI = 3.14159265359;\nconst float TWO_PI = 2.0 * PI;vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\nreturn a + b*cos( TAU*(c*t+d) );\n}float drawLine(vec2 uv, vec2 center, float scale, float angle) {\nfloat radAngle = -angle * TWO_PI;\nfloat phase = fract(uTime * 0.01 + 0.5300) * (3. * max(1., scale)) - (1.5 * max(1., scale));vec2 direction = vec2(cos(radAngle), sin(radAngle));vec2 centerToPoint = uv - center;float projection = dot(centerToPoint, direction);float distToLine = length(centerToPoint - projection * direction);float lineRadius = uThickness * 0.25;\nfloat brightness = lineRadius / max(0.0001, 1. - smoothstep(0.4, 0., distToLine + 0.02));float glowRadius = scale;\nfloat glow = smoothstep(glowRadius, 0.0, abs(projection - phase));return brightness * (1.-distToLine)*(1.-distToLine) * glow;\n}float getBeam(vec2 uv) {\nvec2 pos = vec2(0.5, 0) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nreturn drawLine(uv, pos, 1.5940, 0.2500);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);float beam = getBeam(uv);\nfloat ssBeam = smoothstep(0.0, 1.0, beam);\nfloat chroma = 0.4;vec3 beamColor = pal(beam,\n(vec3(0.9019607843137255, 0.7568627450980392, 0) + vec3(0.5)) * 0.5,\nvec3(0.5) - vec3(0.9019607843137255, 0.7568627450980392, 0),\nvec3(1.0 - chroma, 1.0, 1. + chroma),\nvec3(chroma, 0., -chroma)\n);beamColor = mix(beamColor, vec3(0.9019607843137255, 0.7568627450980392, 0), mix(1.0, ssBeam, 0.0000)) * beam;\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beamColor), bg.rgb);\nvec3 result = mix(bg.rgb, blended, 1.0000);\nresult += dither;vec4 color = vec4(result, max(bg.a, beam));\nfragColor = color;}"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"
            ],
            "data": {
                "depth": false,
                "uniforms": {},
                "isBackground": false
            },
            "id": "beam"
        },
        {
            "breakpoints": [],
            "visible": false,
            "aspectRatio": 1,
            "userDownsample": 1,
            "layerType": "effect",
            "type": "fbm",
            "usesPingPong": false,
            "speed": 0.6,
            "trackMouse": 0.02,
            "trackAxes": "xy",
            "mouseMomentum": 1,
            "texture": false,
            "animating": true,
            "isMask": 0,
            "compiledFragmentShaders": [
                "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;float ease (int easingFunc, float t) {\nreturn t;\n}vec3 hash33(vec3 p3) {\np3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\np3 += dot(p3, p3.yxz + 19.19);\nreturn -1.0 + 2.0 * fract(vec3(\n(p3.x + p3.y) * p3.z,\n(p3.x + p3.z) * p3.y,\n(p3.y + p3.z) * p3.x\n));\n}float perlin_noise(vec3 p) {\nvec3 pi = floor(p);\nvec3 pf = p - pi;vec3 w = pf * pf * (3.0 - 2.0 * pf);float n000 = dot(pf - vec3(0.0, 0.0, 0.0), hash33(pi + vec3(0.0, 0.0, 0.0)));\nfloat n100 = dot(pf - vec3(1.0, 0.0, 0.0), hash33(pi + vec3(1.0, 0.0, 0.0)));\nfloat n010 = dot(pf - vec3(0.0, 1.0, 0.0), hash33(pi + vec3(0.0, 1.0, 0.0)));\nfloat n110 = dot(pf - vec3(1.0, 1.0, 0.0), hash33(pi + vec3(1.0, 1.0, 0.0)));\nfloat n001 = dot(pf - vec3(0.0, 0.0, 1.0), hash33(pi + vec3(0.0, 0.0, 1.0)));\nfloat n101 = dot(pf - vec3(1.0, 0.0, 1.0), hash33(pi + vec3(1.0, 0.0, 1.0)));\nfloat n011 = dot(pf - vec3(0.0, 1.0, 1.0), hash33(pi + vec3(0.0, 1.0, 1.0)));\nfloat n111 = dot(pf - vec3(1.0, 1.0, 1.0), hash33(pi + vec3(1.0, 1.0, 1.0)));float nx00 = mix(n000, n100, w.x);\nfloat nx01 = mix(n001, n101, w.x);\nfloat nx10 = mix(n010, n110, w.x);\nfloat nx11 = mix(n011, n111, w.x);float nxy0 = mix(nx00, nx10, w.y);\nfloat nxy1 = mix(nx01, nx11, w.y);float nxyz = mix(nxy0, nxy1, w.z);return nxyz;\n}\nconst float PI = 3.14159265359;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}mat2 rotHalf = mat2(cos(0.5), sin(0.5),\n-sin(0.5), cos(0.5));float fbm (in vec3 st) {\nfloat value = 0.0;\nfloat amp = .25;\nfloat frequency = 0.;\nfloat aM = (0.1 + 0.8600 * .65);\nvec2 shift = vec2(100.0);\nfor (int i = 0; i < 5; i++) {\nvalue += amp * perlin_noise(st);\nst.xy *= rotHalf * 2.5;\nst.xy += shift;\namp *= aM;\n}\nreturn value;\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nfloat aspectRatio = uResolution.x/uResolution.y;\nfloat multiplier = 6.0 * (0.2280 / ((aspectRatio + 1.) / 2.));vec2 mPos = vec2(0.5010729613733905, 0.6716738197424893) + mix(vec2(0), (uMousePos-0.5), 0.0200);\nvec2 pos = mix(vec2(0.5010729613733905, 0.6716738197424893), mPos, floor(1.0000));\nfloat mDist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));\nvec2 skew = mix(vec2(1), vec2(1, 0), 0.0000);\nvec2 st = ((uv - pos) * vec2(aspectRatio, 1)) * multiplier * aspectRatio;\nst = rot(-0.0135 * -2. * PI) * st * skew;\nvec2 drift = vec2(0, uTime * 0.005) * (0.8000 * 2.);float time = uTime * 0.025;vec2 r = vec2(\nfbm(vec3(st - drift + vec2(1.7, 9.2), 0.0000*25. + time)),\nfbm(vec3(st - drift + vec2(8.2, 1.3), 0.0000*25. + time))\n);float f = fbm(vec3(st + r - drift, 0.0000*25. + time)) * 1.4700;vec2 offset = (f * 2. + (r * 1.4700));vec4 color = texture(uTexture, uv + offset * mDist);\nfragColor = color;}"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"
            ],
            "data": {
                "depth": false,
                "uniforms": {},
                "isBackground": false
            },
            "id": "fbm"
        },
        {
            "breakpoints": [],
            "visible": false,
            "aspectRatio": 1,
            "userDownsample": 1,
            "states": {
                "appear": [
                    {
                        "local": {
                            "pendingChanges": {},
                            "changeDebouncer": null,
                            "dragSession": null
                        },
                        "type": "appear",
                        "id": "5c528401-bc9e-46c7-9fd9-3c19fb9178e2",
                        "prop": "radius",
                        "transition": {
                            "delay": 0,
                            "ease": "easeInOutQuart",
                            "duration": 1000
                        },
                        "complete": false,
                        "progress": 0,
                        "value": 0,
                        "endValue": 0.42,
                        "initialized": false,
                        "breakpoints": [],
                        "loop": "none",
                        "loopDelay": 0,
                        "uniformData": {
                            "type": "1f",
                            "name": "uRadius"
                        }
                    }
                ],
                "scroll": [],
                "hover": [],
                "mousemove": []
            },
            "layerType": "effect",
            "type": "vignette",
            "usesPingPong": false,
            "radius": 0.42,
            "trackMouse": 0,
            "trackAxes": "xy",
            "mouseMomentum": 0,
            "texture": false,
            "animating": false,
            "isMask": 0,
            "compiledFragmentShaders": [
                "#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform float uRadius;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn min(src, dst);\n}out vec4 fragColor;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);\nfloat luma = dot(bg.rgb, vec3(0.299, 0.587, 0.114));\nfloat displacement = (luma - 0.5) * 0.0000 * 0.5;\nvec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0);\nvec2 skew = vec2(0.6300, 1.0 - 0.6300);\nfloat halfRadius = uRadius * 0.5;\nfloat innerEdge = halfRadius - 1.0000 * halfRadius * 0.5;\nfloat outerEdge = halfRadius + 1.0000 * halfRadius * 0.5;\nvec2 pos = vec2(0.5, 0);\nconst float TWO_PI = 6.28318530718;\nvec2 scaledUV = uv * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nvec2 scaledPos = pos * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nfloat radius = distance(scaledUV, scaledPos);\nfloat falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);\nvec3 finalColor;vec3 blended = blend(6, vec3(0, 0, 0), bg.rgb);\nfinalColor = mix(bg.rgb, blended, falloff * 1.0000);float alpha = max(bg.a, falloff * 1.0000);\nvec4 color = mix(bg * (1.-falloff), vec4(finalColor * alpha, alpha), 1.0000);\nfragColor = color;}"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"
            ],
            "data": {
                "depth": false,
                "uniforms": {},
                "isBackground": false
            },
            "id": "vignette"
        },
        {
            "breakpoints": [
                {
                    "min": 992,
                    "props": {
                        "top": 0.4766666666666667,
                        "left": 0.5,
                        "width": 1700.4594594594596
                    },
                    "max": null,
                    "name": "Desktop"
                },
                {
                    "name": "Tablet",
                    "min": 576,
                    "max": 991,
                    "props": {
                        "left": 0.5,
                        "top": 0.501567268371582,
                        "width": 1852.9033783783786
                    }
                },
                {
                    "props": {
                        "top": 0.48497959064646357
                    },
                    "min": 0,
                    "max": 575,
                    "name": "Mobile"
                }
            ],
            "aspectRatio": 1.7297297297297298,
            "userDownsample": 1,
            "states": {
                "appear": [],
                "scroll": [],
                "hover": [],
                "mousemove": []
            },
            "effects": [],
            "anchorPoint": 8,
            "mask": 0,
            "maskDepthLayer": 1,
            "layerType": "image",
            "width": 1700.4594594594596,
            "widthMode": 1,
            "height": 983.078125,
            "heightMode": 2,
            "left": 0.5,
            "top": 0.4766666666666667,
            "src": "https://assets.unicorn.studio/images/eduqN1o36PR2JR87ZZzR3eoHmb32/TAAM%20Lit%20(1)_compressed.png",
            "imageNaturalSize": {
                "type": "Vec2",
                "_x": 1280,
                "_y": 740
            },
            "compiledFragmentShaders": [
                "#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uSourceImage;\nuniform float uWidth;\nuniform float uLeft;\nuniform float uTop;uniform vec2 uArtboardResolution;\nuniform vec2 uMousePos;\nuniform sampler2D uBgTexture;vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn 1. - (1. - src) * (1. - dst);\n}const float TAU = 6.28318530718;\nconst float PI = 3.1415926;out vec4 fragColor;vec2 rotate2D(vec2 p, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}vec2 apply3DRotation(vec2 uv, vec2 elementCenter, vec2 elementSize, float rotX, float rotY, float fov, vec2 mouseRotOffset) {\nfloat angleX = rotX * TAU + mouseRotOffset.y;\nfloat angleY = rotY * TAU + mouseRotOffset.x;\nif (abs(angleX) < 0.001 && abs(angleY) < 0.001) {\nreturn uv;\n}\nvec2 pos = uv - 0.5;\nfloat aspect = elementSize.x / elementSize.y;\npos.x *= aspect;\nfloat focalLength = mix(0.5, 4.0, fov);\nfloat cosX = cos(angleX);\nfloat sinX = sin(angleX);\nfloat cosY = cos(angleY);\nfloat sinY = sin(angleY);\nvec3 rayDir = normalize(vec3(pos.x, pos.y, focalLength));\nvec3 r1;\nr1.x = rayDir.x * cosY - rayDir.z * sinY;\nr1.y = rayDir.y;\nr1.z = rayDir.x * sinY + rayDir.z * cosY;\nvec3 r2;\nr2.x = r1.x;\nr2.y = r1.y * cosX + r1.z * sinX;\nr2.z = -r1.y * sinX + r1.z * cosX;\nvec3 camPos = vec3(0.0, 0.0, -focalLength);\nvec3 c1;\nc1.x = camPos.x * cosY - camPos.z * sinY;\nc1.y = camPos.y;\nc1.z = camPos.x * sinY + camPos.z * cosY;\nvec3 c2;\nc2.x = c1.x;\nc2.y = c1.y * cosX + c1.z * sinX;\nc2.z = -c1.y * sinX + c1.z * cosX;\nif (abs(r2.z) < 0.01) {\nreturn vec2(-1.0);\n}\nfloat t = -c2.z / r2.z;\nif (t < 0.0 || t > 50.0) {\nreturn vec2(-1.0);\n}\nvec2 intersection = vec2(c2.x + t * r2.x, c2.y + t * r2.y);\nif (abs(intersection.x) > 2.0 || abs(intersection.y) > 2.0) {\nreturn vec2(-1.0);\n}\nintersection.x /= aspect;\nreturn intersection + 0.5;\n}vec2 getAnchorOffsets() {\nreturn vec2(0.5, 0.5);\n}vec4 sampleImage(vec2 canvasUV, vec2 mouseOffset, vec2 mouseRotOffset) {\nvec2 canvasPos = vec2(canvasUV.x * uArtboardResolution.x, (1.0 - canvasUV.y) * uArtboardResolution.y);\nvec2 imageUV;float absWidth = uWidth;\nfloat absHeight = 983.0781 * uArtboardResolution.y;if (1 == 2) {\nabsWidth = absHeight * 1.7297;\n} else if (2 == 2) {\nabsHeight = absWidth / 1.7297;\n}vec2 elementSizePx = vec2(absWidth, absHeight);\nvec2 elementPosPx = vec2(uLeft, uTop) * uArtboardResolution - getAnchorOffsets() * elementSizePx;vec2 centerPos = elementPosPx + (elementSizePx * 0.5);\nvec2 relPos = canvasPos - centerPos + mouseOffset;\nvec2 unrotatedRelPos = rotate2D(relPos, 0.0000 * -TAU);\nvec2 elementPos = unrotatedRelPos + (elementSizePx * 0.5);\nimageUV = elementPos / elementSizePx;\nimageUV = apply3DRotation(imageUV, vec2(0.5), vec2(1280, 740), 0.0000, 0.0000, 0.5000, mouseRotOffset);\nvec2 flippedUV = vec2(imageUV.x, 1.0 - imageUV.y);\nvec4 color = textureLod(uSourceImage, flippedUV, 0.0);\nif (imageUV.x >= 0.0 && imageUV.x <= 1.0 && imageUV.y >= 0.0 && imageUV.y <= 1.0) {\nreturn color;\n} else {\nreturn vec4(0.0);\n}\n}vec4 getNormalOutput(vec4 color, vec4 background) {\nvec3 unpremultColor = color.rgb / max(color.a, 0.0001);\nvec3 blendedColor = blend(4, unpremultColor, background.rgb);\ncolor = vec4(blendedColor, 1.0) * (color.a * 1.0000);\ncolor = color + background * (1.0 - color.a);\nreturn color;\nreturn mix(background, color + background * (1.0 - color.a), 1.0000);\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}vec4 applyImageAdjustments(vec4 color) {color.rgb = clamp(color.rgb, 0.0, 1.0);\ncolor.rgb *= color.a;\nreturn color;\n}vec4 getCompositeOutput(vec2 uv, vec2 mouseOffsetPx, vec2 mouseRotOffset) {\nvec4 background = vec4(0);background = texture(uBgTexture, vTextureCoord);\nvec4 color = sampleImage(uv, mouseOffsetPx, mouseRotOffset);\ncolor = applyImageAdjustments(color);return getOutputByMode(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 mouseOffsetUV = (uMousePos - 0.5) * 0.0000;\nvec2 mouseOffsetPx = mouseOffsetUV;\nvec2 mouseRotOffset = (uMousePos - 0.5) * 0.0000 * PI * 0.5;\nuv -= mouseOffsetUV;\nfragColor = getCompositeOutput(uv, mouseOffsetPx, mouseRotOffset);\n}"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"
            ],
            "data": {
                "uniforms": {
                    "artboardResolution": {
                        "name": "uArtboardResolution",
                        "type": "2f",
                        "value": {
                            "type": "Vec2",
                            "_x": 1440,
                            "_y": 900
                        }
                    },
                    "aspectRatio": {
                        "name": "uAspectRatio",
                        "type": "1f",
                        "value": 1.7297297297297298
                    },
                    "left": {
                        "name": "uLeft",
                        "type": "1f",
                        "value": 0
                    },
                    "top": {
                        "name": "uTop",
                        "type": "1f",
                        "value": 0
                    },
                    "width": {
                        "name": "uWidth",
                        "type": "1f",
                        "value": 512
                    }
                }
            },
            "id": "image"
        },
        {
            "breakpoints": [],
            "visible": false,
            "aspectRatio": 1,
            "userDownsample": 1,
            "states": {
                "appear": [
                    {
                        "local": {
                            "pendingChanges": {},
                            "changeDebouncer": null,
                            "dragSession": null
                        },
                        "type": "appear",
                        "id": "ef44b178-267e-480e-ab88-c6c5703037f5",
                        "prop": "thickness",
                        "transition": {
                            "ease": "easeInOutQuart",
                            "delay": 0,
                            "duration": 1000
                        },
                        "complete": false,
                        "progress": 0,
                        "value": 0,
                        "endValue": 0.28,
                        "initialized": false,
                        "breakpoints": [],
                        "loop": "none",
                        "loopDelay": 0,
                        "uniformData": {
                            "type": "1f",
                            "name": "uThickness"
                        }
                    }
                ],
                "scroll": [],
                "hover": [],
                "mousemove": []
            },
            "layerType": "effect",
            "type": "beam",
            "usesPingPong": false,
            "thickness": 0.28,
            "speed": 0.6,
            "trackMouse": 0,
            "trackAxes": "xy",
            "mouseMomentum": 0,
            "texture": false,
            "animating": true,
            "isMask": 0,
            "compiledFragmentShaders": [
                "#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uThickness;\nuniform float uTime;uniform vec2 uMousePos;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float TAU = 6.28318530718;vec3 Tonemap_tanh(vec3 x) {\nx = clamp(x, -40.0, 40.0);\nreturn (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}out vec4 fragColor;const float PI = 3.14159265359;\nconst float TWO_PI = 2.0 * PI;vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\nreturn a + b*cos( TAU*(c*t+d) );\n}float drawLine(vec2 uv, vec2 center, float scale, float angle) {\nfloat radAngle = -angle * TWO_PI;\nfloat phase = fract(uTime * 0.01 + 0.5000) * (3. * max(1., scale)) - (1.5 * max(1., scale));vec2 direction = vec2(cos(radAngle), sin(radAngle));vec2 centerToPoint = uv - center;float projection = dot(centerToPoint, direction);float distToLine = length(centerToPoint - projection * direction);float lineRadius = uThickness * 0.25;\nfloat brightness = lineRadius / max(0.0001, 1. - smoothstep(0.4, 0., distToLine + 0.02));float glowRadius = scale;\nfloat glow = smoothstep(glowRadius, 0.0, abs(projection - phase));return brightness * (1.-distToLine)*(1.-distToLine) * glow;\n}float getBeam(vec2 uv) {\nvec2 pos = vec2(0.5, 0) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nreturn drawLine(uv, pos, 0.3080, 0.0000);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);float beam = getBeam(uv);\nfloat ssBeam = smoothstep(0.0, 1.0, beam);\nfloat chroma = 0.4;vec3 beamColor = pal(beam,\n(vec3(0.8156862745098039, 0.8156862745098039, 0.8156862745098039) + vec3(0.5)) * 0.5,\nvec3(0.5) - vec3(0.8156862745098039, 0.8156862745098039, 0.8156862745098039),\nvec3(1.0 - chroma, 1.0, 1. + chroma),\nvec3(chroma, 0., -chroma)\n);beamColor = mix(beamColor, vec3(0.8156862745098039, 0.8156862745098039, 0.8156862745098039), mix(1.0, ssBeam, 0.0000)) * beam;\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beamColor), bg.rgb);\nvec3 result = mix(bg.rgb, blended, 1.0000);\nresult += dither;vec4 color = vec4(result, max(bg.a, beam));\nfragColor = color;}"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"
            ],
            "data": {
                "depth": false,
                "uniforms": {},
                "isBackground": false
            },
            "id": "beam1"
        },
        {
            "breakpoints": [],
            "visible": true,
            "aspectRatio": 1,
            "userDownsample": 1,
            "layerType": "effect",
            "type": "wisps",
            "usesPingPong": false,
            "speed": 1.0,
            "trackMouse": 0,
            "trackAxes": "xy",
            "mouseMomentum": 1,
            "texture": false,
            "animating": true,
            "isMask": 0,
            "compiledFragmentShaders": [
                "#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}out vec4 fragColor;\nconst float PI = 3.14159265359;\nmat2 rot(float a) {\nreturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}vec2 hash(vec2 p) {\np = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\nreturn -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}float voronoi_additive(vec2 st, float radius, vec2 mouse_pos, float scale) {\nvec2 i_st = floor(st);\nvec2 f_st = fract(st);float wander = 0.0000 * uTime * 0.2;\nfloat total_contribution = 0.0;for (int y = -2; y <= 2; y++) {\nfor (int x = -2; x <= 2; x++) {\nvec2 neighbor = vec2(float(x), float(y));\nvec2 cell_id = i_st + neighbor;\nvec2 point = hash(cell_id);\npoint = 0.5 + 0.5 * sin(5. + wander + 6.2831 * point);\nvec2 starAbsPos = cell_id + point;\nvec2 dirToMouse = mouse_pos - starAbsPos;\nfloat distToMouse = length(dirToMouse);\nfloat attractStrength = 0.0000 * exp(-distToMouse * mix(2.0 + 4.5600 * 2., 0.5, 0.5000)) * 2.;\nstarAbsPos += dirToMouse * attractStrength;\nvec2 diff = starAbsPos - st;\nfloat dist = length(diff);float contribution = radius / max(dist, radius * 0.1);\nfloat shimmer_phase = dot(point, vec2(1.0)) * 10. + hash(cell_id).x * 5.0 + uTime * 0.5;\nfloat shimmer = mix(1., (sin(shimmer_phase) + 1.), 0.4400);\ncontribution *= shimmer;\ntotal_contribution += mix(contribution*contribution, contribution * 2., 0.2500);\n}\n}return total_contribution;\n}vec4 randomStyle() {\nvec2 uv = vTextureCoord;vec4 bg = texture(uTexture, uv);vec4 color = vec4(0.0);\nvec2 aspectRatio = vec2(uResolution.x / uResolution.y, 1.0);vec2 mPos = mix(vec2(0.0), (uMousePos - 0.5), 0.0000);uv -= vec2(0.5, 0.5);\nuv *= aspectRatio;\nuv = uv * rot(0.5000 * 2.0 * PI);\nuv *= 40.0 * 4.5600;\nuv *= mix(vec2(1.0), vec2(1.0, 0.0), 0.9700);\nuv /= aspectRatio;mPos = mPos * rot(0.5000 * 2.0 * PI);vec2 mouseGrid = uMousePos;\nmouseGrid -= vec2(0.5, 0.5);\nmouseGrid *= aspectRatio;\nmouseGrid = mouseGrid * rot(0.5000 * 2.0 * PI);\nmouseGrid *= 40.0 * 4.5600;\nmouseGrid *= mix(vec2(1.0), vec2(1.0, 0.0), 0.9700);\nmouseGrid /= aspectRatio;vec2 movementOffset = vec2(0.0, uTime * 0.3500 * -0.05);\nvec2 mouseGrid1 = mouseGrid - (mPos * 38.0 * 4.5600) + movementOffset;\nvec2 mouseGrid2 = mouseGrid - (mPos * 48.0 * 4.5600) + movementOffset;vec2 st1 = uv - (mPos * 38.0 * 4.5600);\nvec2 st2 = uv - (mPos * 48.0 * 4.5600);vec2 mouse1 = st1 + vec2(0.0, uTime * 0.3500 * -0.05);\nvec2 mouse2 = st2 + vec2(0.0, uTime * 0.3500 * -0.05);float radius1 = 0.5 * 0.5400;\nfloat radius2 = 0.5 * 0.5400;float pass1 = voronoi_additive(mouse1 * aspectRatio, radius1, mouseGrid1 * aspectRatio, 38.0 * 4.5600);\nfloat pass2 = voronoi_additive(mouse2 * aspectRatio + vec2(10), radius2, mouseGrid2 * aspectRatio + vec2(10.0), 48.0 * 4.5600);pass1 *= 0.02;\npass2 *= 0.04;color.rgb = (pass1 + pass2) * vec3(0.10980392156862745, 0.11372549019607843, 0.12549019607843137) * mix(1.0, bg.r, 1.1500);\ncolor.rgb = clamp(color.rgb, 0.0, 1.0);color.rgb = blend(1, bg.rgb, color.rgb);color = vec4(color.rgb, max(bg.a, luma(color.rgb)));\nreturn color;\n}void main() {\nvec4 color;color = randomStyle();\nfragColor = color;}"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"
            ],
            "data": {
                "depth": false,
                "uniforms": {},
                "isBackground": false
            },
            "id": "wisps"
        }
    ],
    "options": {
        "name": "\"Huly\" laser",
        "fps": 60,
        "dpi": 1.5,
        "scale": 1.3,
        "includeLogo": false,
        "isProduction": true
    },
    "version": "2.0.5",
    "id": "ryXCGIJHz1KVR0TZRWND"
}